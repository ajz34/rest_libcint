#[cfg(test)]
mod coverage_cint {
    use rest_libcint::{CintType, prelude::*};
    use itertools::Itertools;
    use num_complex::*;

    #[test]
    fn cover_crafter() {
        let mut cint_data = initialize();
        cint_data.set_cint_type(&CintType::Cartesian);
        cint_data.integral_s1::<int3c2e>(None);
        cint_data.integral_spinor_s2ij::<int3c2e>(None);
    }

    #[test]
    #[should_panic]
    fn cover_panic_type_inconsistent() {
        let mut cint_data = initialize();
        let shl_slices = vec![[0, 5]; int3c2e_ip1::n_center()];
        let mut out_shape = cint_data.cgto_shape_s2ij::<int3c2e_ip1>(&shl_slices).unwrap();
        if int3c2e_ip1::n_comp() > 1 { out_shape.push(int3c2e_ip1::n_comp()); }
        let out_size = out_shape.iter().product::<usize>();
        let mut out = Vec::<Complex<f64>>::with_capacity(out_size);
        cint_data.integral_s1_inplace::<int3c2e_ip1, _>(&mut out, &shl_slices);
    }

    #[test]
    fn cover_wrapper() {
        println!("{:?}", int3c2e::n_spinor_comp());
        println!("{:?}", int3c2e::ng());
        println!("{:?}", int3c2e::integrator_type());
        println!("{:?}", int3c2e::name());
        let mut cint_data = initialize();
        cint_data.int3c2e_ip1_optimizer_rust();
    }

    fn initialize() -> CINTR2CDATA {
        // mol = gto.Mole(atom="O; H 1 0.94; H 1 0.94 2 104.5", basis="def2-TZVP").build()
        let c_atm = vec![
            [ 8, 20,  1, 23,  0,  0],
            [ 1, 24,  1, 27,  0,  0],
            [ 1, 28,  1, 31,  0,  0],
        ];
        let c_bas = vec![
            [ 0,  0,  6,  1,  0, 44, 50,  0],
            [ 0,  0,  2,  1,  0, 56, 58,  0],
            [ 0,  0,  1,  1,  0, 60, 61,  0],
            [ 0,  0,  1,  1,  0, 62, 63,  0],
            [ 0,  0,  1,  1,  0, 64, 65,  0],
            [ 0,  1,  4,  1,  0, 66, 70,  0],
            [ 0,  1,  1,  1,  0, 74, 75,  0],
            [ 0,  1,  1,  1,  0, 76, 77,  0],
            [ 0,  2,  1,  1,  0, 78, 79,  0],
            [ 0,  2,  1,  1,  0, 80, 81,  0],
            [ 0,  3,  1,  1,  0, 82, 83,  0],
            [ 1,  0,  3,  1,  0, 32, 35,  0],
            [ 1,  0,  1,  1,  0, 38, 39,  0],
            [ 1,  0,  1,  1,  0, 40, 41,  0],
            [ 1,  1,  1,  1,  0, 42, 43,  0],
            [ 2,  0,  3,  1,  0, 32, 35,  0],
            [ 2,  0,  1,  1,  0, 38, 39,  0],
            [ 2,  0,  1,  1,  0, 40, 41,  0],
            [ 2,  1,  1,  1,  0, 42, 43,  0],
        ];
        let c_env = vec![
            0.0000000000000000e+00,  0.0000000000000000e+00,
            0.0000000000000000e+00,  0.0000000000000000e+00,
            0.0000000000000000e+00,  0.0000000000000000e+00,
            0.0000000000000000e+00,  0.0000000000000000e+00,
            0.0000000000000000e+00,  0.0000000000000000e+00,
            0.0000000000000000e+00,  0.0000000000000000e+00,
            0.0000000000000000e+00,  0.0000000000000000e+00,
            0.0000000000000000e+00,  0.0000000000000000e+00,
            0.0000000000000000e+00,  0.0000000000000000e+00,
            0.0000000000000000e+00,  0.0000000000000000e+00,
            0.0000000000000000e+00,  0.0000000000000000e+00,
            0.0000000000000000e+00,  0.0000000000000000e+00,
            1.7763425570911580e+00,  0.0000000000000000e+00,
            0.0000000000000000e+00,  0.0000000000000000e+00,
           -4.4476065664656128e-01,  0.0000000000000000e+00,
            1.7197618551510188e+00,  0.0000000000000000e+00,
            3.4061340999999999e+01,  5.1235746000000004e+00,
            1.1646626000000000e+00,  9.0618446120248586e-01,
            1.6354784928239057e+00,  2.4145128304249659e+00,
            3.2723041000000003e-01,  1.0930883523645869e+00,
            1.0307241000000000e-01,  4.5959135109675275e-01,
            8.0000000000000004e-01,  2.2072263710762661e+00,
            2.7032382631000000e+04,  4.0523871392000001e+03,
            9.2232722709999996e+02,  2.6124070989000001e+02,
            8.5354641350999998e+01,  3.1035035245000000e+01,
            3.0481181169845928e+00,  5.6914576328642115e+00,
            9.7338835744432526e+00,  1.5238733819733028e+01,
            2.0843228934131737e+01,  2.2391049059992991e+01,
            1.2260860728000001e+01,  4.9987076005000004e+00,
            1.0568131135849375e+01,  3.3391469496791393e+00,
            1.1703108158000000e+00,  2.8427648592056753e+00,
            4.6474740994000002e-01,  1.4220922112658689e+00,
            1.8504536357000001e-01,  7.1280983010446131e-01,
            6.3274954801000000e+01,  1.4627049379000001e+01,
            4.4501223455999996e+00,  1.5275799646999999e+00,
            6.2570323747894276e+00,  6.9268656235998423e+00,
            6.0323599265415284e+00,  3.5035168827833356e+00,
            5.2935117942999999e-01,  1.3172379939563448e+00,
            1.7478421270000000e-01,  3.2969483673949351e-01,
            2.3140000000000001e+00,  1.1328313432935008e+01,
            6.4500000000000002e-01,  1.2113199965714336e+00,
            1.4279999999999999e+00,  4.3969226782656516e+00
        ];

        let c_atm = c_atm.iter().map(|&v| v.to_vec()).collect_vec();
        let c_bas = c_bas.iter().map(|&v| v.to_vec()).collect_vec();
        let mut cint_data = CINTR2CDATA::new();
        cint_data.initial_r2c(&c_atm, c_atm.len() as i32, &c_bas, c_bas.len() as i32, &c_env);
        return cint_data;
    }
}